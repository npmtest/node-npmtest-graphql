<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-graphql/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMerged.js</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header low">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-graphql">npmtest-graphql (v0.0.2)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-graphql/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMerged.js</span></h1>
    <h2>
        
        Statements: <span class="metric">17.56% <small>(36 / 205)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">2.8% <small>(3 / 107)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">5.88% <small>(2 / 34)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">17.33% <small>(35 / 202)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric"><span class="ignore-none">none</span></span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../../../../../index.html">All files</a> &#187; <a href="index.html">node-npmtest-graphql/node_modules/graphql/validation/rules/</a> &#187; OverlappingFieldsCanBeMerged.js</div>
</div>
<div class="body">
<pre><table class="coverage">
<tr><td class="line-count">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554</td><td class="line-coverage"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">'use strict';
&nbsp;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fieldsConflictMessage = fieldsConflictMessage;
exports.OverlappingFieldsCanBeMerged = OverlappingFieldsCanBeMerged;
&nbsp;
var _error = require('../../error');
&nbsp;
var _find = require('../../jsutils/find');
&nbsp;
var _find2 = _interopRequireDefault(_find);
&nbsp;
var _kinds = require('../../language/kinds');
&nbsp;
var _printer = require('../../language/printer');
&nbsp;
var _definition = require('../../type/definition');
&nbsp;
var _typeFromAST = require('../../utilities/typeFromAST');
&nbsp;
function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : <span class="branch-1 cbranch-no" title="branch not covered" >{ 'default': obj };</span> }
&nbsp;
<span class="fstat-no" title="function not covered" >function _classCallCheck(instance, Constructor) {</span> <span class="cstat-no" title="statement not covered" >if (!(instance instanceof Constructor)) { <span class="cstat-no" title="statement not covered" >throw new TypeError("Cannot call a class as a function"); </span>} </span>}
/**
 *  Copyright (c) 2015, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 */
&nbsp;
<span class="fstat-no" title="function not covered" >function fieldsConflictMessage(responseName, reason) {</span>
<span class="cstat-no" title="statement not covered" >  return 'Fields "' + responseName + '" conflict because ' + reasonMessage(reason) + '. Use different aliases on the fields to fetch both if this was ' + 'intentional.';</span>
}
&nbsp;
<span class="fstat-no" title="function not covered" >function reasonMessage(reason) {</span>
<span class="cstat-no" title="statement not covered" >  if (Array.isArray(reason)) {</span>
<span class="cstat-no" title="statement not covered" >    return reason.map(<span class="fstat-no" title="function not covered" >function (_ref) {</span></span>
<span class="cstat-no" title="statement not covered" >      var responseName = _ref[0],</span>
          subreason = _ref[1];
<span class="cstat-no" title="statement not covered" >      return 'subfields "' + responseName + '" conflict because ' + reasonMessage(subreason);</span>
    }).join(' and ');
  }
<span class="cstat-no" title="statement not covered" >  return reason;</span>
}
&nbsp;
/**
 * Overlapping fields can be merged
 *
 * A selection set is only valid if all fields (including spreading any
 * fragments) either correspond to distinct response names or can be merged
 * without ambiguity.
 */
<span class="fstat-no" title="function not covered" >function OverlappingFieldsCanBeMerged(context) {</span>
  // A memoization for when two fragments are compared "between" each other for
  // conflicts. Two fragments may be compared many times, so memoizing this can
  // dramatically improve the performance of this validator.
<span class="cstat-no" title="statement not covered" >  var comparedFragments = new PairSet();</span>
&nbsp;
  // A cache for the "field map" and list of fragment names found in any given
  // selection set. Selection sets may be asked for this information multiple
  // times, so this improves the performance of this validator.
<span class="cstat-no" title="statement not covered" >  var cachedFieldsAndFragmentNames = new Map();</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >  return {</span>
    SelectionSet: <span class="fstat-no" title="function not covered" >function SelectionSet(selectionSet) {</span>
<span class="cstat-no" title="statement not covered" >      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragments, context.getParentType(), selectionSet);</span>
<span class="cstat-no" title="statement not covered" >      conflicts.forEach(<span class="fstat-no" title="function not covered" >function (_ref2) {</span></span>
<span class="cstat-no" title="statement not covered" >        var _ref2$ = _ref2[0],</span>
            responseName = _ref2$[0],
            reason = _ref2$[1],
            fields1 = _ref2[1],
            fields2 = _ref2[2];
<span class="cstat-no" title="statement not covered" >        return context.reportError(new _error.GraphQLError(fieldsConflictMessage(responseName, reason), fields1.concat(fields2)));</span>
      });
    }
  };
}
// Field name and reason.
&nbsp;
// Reason is a string, or a nested list of conflicts.
&nbsp;
// Tuple defining a field node in a context.
&nbsp;
// Map of array of those.
&nbsp;
&nbsp;
/**
 * Algorithm:
 *
 * Conflicts occur when two fields exist in a query which will produce the same
 * response name, but represent differing values, thus creating a conflict.
 * The algorithm below finds all conflicts via making a series of comparisons
 * between fields. In order to compare as few fields as possible, this makes
 * a series of comparisons "within" sets of fields and "between" sets of fields.
 *
 * Given any selection set, a collection produces both a set of fields by
 * also including all inline fragments, as well as a list of fragments
 * referenced by fragment spreads.
 *
 * A) Each selection set represented in the document first compares "within" its
 * collected set of fields, finding any conflicts between every pair of
 * overlapping fields.
 * Note: This is the *only time* that a the fields "within" a set are compared
 * to each other. After this only fields "between" sets are compared.
 *
 * B) Also, if any fragment is referenced in a selection set, then a
 * comparison is made "between" the original set of fields and the
 * referenced fragment.
 *
 * C) Also, if multiple fragments are referenced, then comparisons
 * are made "between" each referenced fragment.
 *
 * D) When comparing "between" a set of fields and a referenced fragment, first
 * a comparison is made between each field in the original set of fields and
 * each field in the the referenced set of fields.
 *
 * E) Also, if any fragment is referenced in the referenced selection set,
 * then a comparison is made "between" the original set of fields and the
 * referenced fragment (recursively referring to step D).
 *
 * F) When comparing "between" two fragments, first a comparison is made between
 * each field in the first referenced set of fields and each field in the the
 * second referenced set of fields.
 *
 * G) Also, any fragments referenced by the first must be compared to the
 * second, and any fragments referenced by the second must be compared to the
 * first (recursively referring to step F).
 *
 * H) When comparing two fields, if both have selection sets, then a comparison
 * is made "between" both selection sets, first comparing the set of fields in
 * the first selection set with the set of fields in the second.
 *
 * I) Also, if any fragment is referenced in either selection set, then a
 * comparison is made "between" the other set of fields and the
 * referenced fragment.
 *
 * J) Also, if two fragments are referenced in both selection sets, then a
 * comparison is made "between" the two fragments.
 *
 */
&nbsp;
// Find all conflicts found "within" a selection set, including those found
// via spreading in fragments. Called when visiting each SelectionSet in the
// GraphQL Document.
<span class="fstat-no" title="function not covered" >function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragments, parentType, selectionSet) {</span>
<span class="cstat-no" title="statement not covered" >  var conflicts = [];</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet),</span>
      fieldMap = _getFieldsAndFragment[0],
      fragmentNames = _getFieldsAndFragment[1];
&nbsp;
  // (A) Find find all conflicts "within" the fields of this selection set.
  // Note: this is the *only place* `collectConflictsWithin` is called.
&nbsp;
&nbsp;
<span class="cstat-no" title="statement not covered" >  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, fieldMap);</span>
&nbsp;
  // (B) Then collect conflicts between these fields and those represented by
  // each spread fragment name found.
<span class="cstat-no" title="statement not covered" >  for (var i = 0; i &lt; fragmentNames.length; i++) {</span>
<span class="cstat-no" title="statement not covered" >    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, false, fieldMap, fragmentNames[i]);</span>
    // (C) Then compare this fragment with all other fragments found in this
    // selection set to collect conflicts between fragments spread together.
    // This compares each item in the list of fragment names to every other item
    // in that same list (except for itself).
<span class="cstat-no" title="statement not covered" >    for (var j = i + 1; j &lt; fragmentNames.length; j++) {</span>
<span class="cstat-no" title="statement not covered" >      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, false, fragmentNames[i], fragmentNames[j]);</span>
    }
  }
<span class="cstat-no" title="statement not covered" >  return conflicts;</span>
}
&nbsp;
// Collect all conflicts found between a set of fields and a fragment reference
// including via spreading in any nested fragments.
<span class="fstat-no" title="function not covered" >function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap, fragmentName) {</span>
<span class="cstat-no" title="statement not covered" >  var fragment = context.getFragment(fragmentName);</span>
<span class="cstat-no" title="statement not covered" >  if (!fragment) {</span>
<span class="cstat-no" title="statement not covered" >    return;</span>
  }
&nbsp;
<span class="cstat-no" title="statement not covered" >  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment),</span>
      fieldMap2 = _getReferencedFieldsA[0],
      fragmentNames2 = _getReferencedFieldsA[1];
&nbsp;
  // (D) First collect any conflicts between the provided collection of fields
  // and the collection of fields represented by the given fragment.
&nbsp;
&nbsp;
<span class="cstat-no" title="statement not covered" >  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap, fieldMap2);</span>
&nbsp;
  // (E) Then collect any conflicts between the provided collection of fields
  // and any fragment names found in the given fragment.
<span class="cstat-no" title="statement not covered" >  for (var i = 0; i &lt; fragmentNames2.length; i++) {</span>
<span class="cstat-no" title="statement not covered" >    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap, fragmentNames2[i]);</span>
  }
}
&nbsp;
// Collect all conflicts found between two fragments, including via spreading in
// any nested fragments.
<span class="fstat-no" title="function not covered" >function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fragmentName1, fragmentName2) {</span>
<span class="cstat-no" title="statement not covered" >  var fragment1 = context.getFragment(fragmentName1);</span>
<span class="cstat-no" title="statement not covered" >  var fragment2 = context.getFragment(fragmentName2);</span>
<span class="cstat-no" title="statement not covered" >  if (!fragment1 || !fragment2) {</span>
<span class="cstat-no" title="statement not covered" >    return;</span>
  }
&nbsp;
  // No need to compare a fragment to itself.
<span class="cstat-no" title="statement not covered" >  if (fragment1 === fragment2) {</span>
<span class="cstat-no" title="statement not covered" >    return;</span>
  }
&nbsp;
  // Memoize so two fragments are not compared for conflicts more than once.
<span class="cstat-no" title="statement not covered" >  if (comparedFragments.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {</span>
<span class="cstat-no" title="statement not covered" >    return;</span>
  }
<span class="cstat-no" title="statement not covered" >  comparedFragments.add(fragmentName1, fragmentName2, areMutuallyExclusive);</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1),</span>
      fieldMap1 = _getReferencedFieldsA2[0],
      fragmentNames1 = _getReferencedFieldsA2[1];
&nbsp;
<span class="cstat-no" title="statement not covered" >  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2),</span>
      fieldMap2 = _getReferencedFieldsA3[0],
      fragmentNames2 = _getReferencedFieldsA3[1];
&nbsp;
  // (F) First, collect all conflicts between these two collections of fields
  // (not including any nested fragments).
&nbsp;
&nbsp;
<span class="cstat-no" title="statement not covered" >  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap1, fieldMap2);</span>
&nbsp;
  // (G) Then collect conflicts between the first fragment and any nested
  // fragments spread in the second fragment.
<span class="cstat-no" title="statement not covered" >  for (var j = 0; j &lt; fragmentNames2.length; j++) {</span>
<span class="cstat-no" title="statement not covered" >    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);</span>
  }
&nbsp;
  // (G) Then collect conflicts between the second fragment and any nested
  // fragments spread in the first fragment.
<span class="cstat-no" title="statement not covered" >  for (var i = 0; i &lt; fragmentNames1.length; i++) {</span>
<span class="cstat-no" title="statement not covered" >    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fragmentNames1[i], fragmentName2);</span>
  }
}
&nbsp;
// Find all conflicts found between two selection sets, including those found
// via spreading in fragments. Called when determining if conflicts exist
// between the sub-fields of two overlapping fields.
<span class="fstat-no" title="function not covered" >function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {</span>
<span class="cstat-no" title="statement not covered" >  var conflicts = [];</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1),</span>
      fieldMap1 = _getFieldsAndFragment2[0],
      fragmentNames1 = _getFieldsAndFragment2[1];
&nbsp;
<span class="cstat-no" title="statement not covered" >  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2),</span>
      fieldMap2 = _getFieldsAndFragment3[0],
      fragmentNames2 = _getFieldsAndFragment3[1];
&nbsp;
  // (H) First, collect all conflicts between these two collections of field.
&nbsp;
&nbsp;
<span class="cstat-no" title="statement not covered" >  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap1, fieldMap2);</span>
&nbsp;
  // (I) Then collect conflicts between the first collection of fields and
  // those referenced by each fragment name associated with the second.
<span class="cstat-no" title="statement not covered" >  for (var j = 0; j &lt; fragmentNames2.length; j++) {</span>
<span class="cstat-no" title="statement not covered" >    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);</span>
  }
&nbsp;
  // (I) Then collect conflicts between the second collection of fields and
  // those referenced by each fragment name associated with the first.
<span class="cstat-no" title="statement not covered" >  for (var i = 0; i &lt; fragmentNames1.length; i++) {</span>
<span class="cstat-no" title="statement not covered" >    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);</span>
  }
&nbsp;
  // (J) Also collect conflicts between any fragment names by the first and
  // fragment names by the second. This compares each item in the first set of
  // names to each item in the second set of names.
<span class="cstat-no" title="statement not covered" >  for (var _i = 0; _i &lt; fragmentNames1.length; _i++) {</span>
<span class="cstat-no" title="statement not covered" >    for (var _j = 0; _j &lt; fragmentNames2.length; _j++) {</span>
<span class="cstat-no" title="statement not covered" >      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, fragmentNames1[_i], fragmentNames2[_j]);</span>
    }
  }
<span class="cstat-no" title="statement not covered" >  return conflicts;</span>
}
&nbsp;
// Collect all Conflicts "within" one collection of fields.
<span class="fstat-no" title="function not covered" >function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, fieldMap) {</span>
  // A field map is a keyed collection, where each key represents a response
  // name and the value at that key is a list of all fields which provide that
  // response name. For every response name, if there are multiple fields, they
  // must be compared to find a potential conflict.
<span class="cstat-no" title="statement not covered" >  Object.keys(fieldMap).forEach(<span class="fstat-no" title="function not covered" >function (responseName) {</span></span>
<span class="cstat-no" title="statement not covered" >    var fields = fieldMap[responseName];</span>
    // This compares every field in the list to every other field in this list
    // (except to itself). If the list only has one item, nothing needs to
    // be compared.
<span class="cstat-no" title="statement not covered" >    if (fields.length &gt; 1) {</span>
<span class="cstat-no" title="statement not covered" >      for (var i = 0; i &lt; fields.length; i++) {</span>
<span class="cstat-no" title="statement not covered" >        for (var j = i + 1; j &lt; fields.length; j++) {</span>
<span class="cstat-no" title="statement not covered" >          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragments, false, // within one collection is never mutually exclusive</span>
          responseName, fields[i], fields[j]);
<span class="cstat-no" title="statement not covered" >          if (conflict) {</span>
<span class="cstat-no" title="statement not covered" >            conflicts.push(conflict);</span>
          }
        }
      }
    }
  });
}
&nbsp;
// Collect all Conflicts between two collections of fields. This is similar to,
// but different from the `collectConflictsWithin` function above. This check
// assumes that `collectConflictsWithin` has already been called on each
// provided collection of fields. This is true because this validator traverses
// each individual selection set.
<span class="fstat-no" title="function not covered" >function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {</span>
  // A field map is a keyed collection, where each key represents a response
  // name and the value at that key is a list of all fields which provide that
  // response name. For any response name which appears in both provided field
  // maps, each field from the first field map must be compared to every field
  // in the second field map to find potential conflicts.
<span class="cstat-no" title="statement not covered" >  Object.keys(fieldMap1).forEach(<span class="fstat-no" title="function not covered" >function (responseName) {</span></span>
<span class="cstat-no" title="statement not covered" >    var fields2 = fieldMap2[responseName];</span>
<span class="cstat-no" title="statement not covered" >    if (fields2) {</span>
<span class="cstat-no" title="statement not covered" >      var fields1 = fieldMap1[responseName];</span>
<span class="cstat-no" title="statement not covered" >      for (var i = 0; i &lt; fields1.length; i++) {</span>
<span class="cstat-no" title="statement not covered" >        for (var j = 0; j &lt; fields2.length; j++) {</span>
<span class="cstat-no" title="statement not covered" >          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragments, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);</span>
<span class="cstat-no" title="statement not covered" >          if (conflict) {</span>
<span class="cstat-no" title="statement not covered" >            conflicts.push(conflict);</span>
          }
        }
      }
    }
  });
}
&nbsp;
// Determines if there is a conflict between two particular fields, including
// comparing their sub-fields.
<span class="fstat-no" title="function not covered" >function findConflict(context, cachedFieldsAndFragmentNames, comparedFragments, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {</span>
<span class="cstat-no" title="statement not covered" >  var parentType1 = field1[0],</span>
      node1 = field1[1],
      def1 = field1[2];
<span class="cstat-no" title="statement not covered" >  var parentType2 = field2[0],</span>
      node2 = field2[1],
      def2 = field2[2];
&nbsp;
  // If it is known that two fields could not possibly apply at the same
  // time, due to the parent types, then it is safe to permit them to diverge
  // in aliased field or arguments used as they will not present any ambiguity
  // by differing.
  // It is known that two parent types could never overlap if they are
  // different Object types. Interface or Union types might overlap - if not
  // in the current state of the schema, then perhaps in some future version,
  // thus may not safely diverge.
&nbsp;
<span class="cstat-no" title="statement not covered" >  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 &amp;&amp; parentType1 instanceof _definition.GraphQLObjectType &amp;&amp; parentType2 instanceof _definition.GraphQLObjectType;</span>
&nbsp;
  // The return type for each field.
<span class="cstat-no" title="statement not covered" >  var type1 = def1 &amp;&amp; def1.type;</span>
<span class="cstat-no" title="statement not covered" >  var type2 = def2 &amp;&amp; def2.type;</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >  if (!areMutuallyExclusive) {</span>
    // Two aliases must refer to the same field.
<span class="cstat-no" title="statement not covered" >    var name1 = node1.name.value;</span>
<span class="cstat-no" title="statement not covered" >    var name2 = node2.name.value;</span>
<span class="cstat-no" title="statement not covered" >    if (name1 !== name2) {</span>
<span class="cstat-no" title="statement not covered" >      return [[responseName, name1 + ' and ' + name2 + ' are different fields'], [node1], [node2]];</span>
    }
&nbsp;
    // Two field calls must have the same arguments.
<span class="cstat-no" title="statement not covered" >    if (!sameArguments(node1.arguments || [], node2.arguments || [])) {</span>
<span class="cstat-no" title="statement not covered" >      return [[responseName, 'they have differing arguments'], [node1], [node2]];</span>
    }
  }
&nbsp;
<span class="cstat-no" title="statement not covered" >  if (type1 &amp;&amp; type2 &amp;&amp; doTypesConflict(type1, type2)) {</span>
<span class="cstat-no" title="statement not covered" >    return [[responseName, 'they return conflicting types ' + String(type1) + ' and ' + String(type2)], [node1], [node2]];</span>
  }
&nbsp;
  // Collect and compare sub-fields. Use the same "visited fragment names" list
  // for both collections so fields in a fragment reference are never
  // compared to themselves.
<span class="cstat-no" title="statement not covered" >  var selectionSet1 = node1.selectionSet;</span>
<span class="cstat-no" title="statement not covered" >  var selectionSet2 = node2.selectionSet;</span>
<span class="cstat-no" title="statement not covered" >  if (selectionSet1 &amp;&amp; selectionSet2) {</span>
<span class="cstat-no" title="statement not covered" >    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragments, areMutuallyExclusive, (0, _definition.getNamedType)(type1), selectionSet1, (0, _definition.getNamedType)(type2), selectionSet2);</span>
<span class="cstat-no" title="statement not covered" >    return subfieldConflicts(conflicts, responseName, node1, node2);</span>
  }
}
&nbsp;
<span class="fstat-no" title="function not covered" >function sameArguments(arguments1, arguments2) {</span>
<span class="cstat-no" title="statement not covered" >  if (arguments1.length !== arguments2.length) {</span>
<span class="cstat-no" title="statement not covered" >    return false;</span>
  }
<span class="cstat-no" title="statement not covered" >  return arguments1.every(<span class="fstat-no" title="function not covered" >function (argument1) {</span></span>
<span class="cstat-no" title="statement not covered" >    var argument2 = (0, _find2.default)(arguments2, <span class="fstat-no" title="function not covered" >function (argument) {</span></span>
<span class="cstat-no" title="statement not covered" >      return argument.name.value === argument1.name.value;</span>
    });
<span class="cstat-no" title="statement not covered" >    if (!argument2) {</span>
<span class="cstat-no" title="statement not covered" >      return false;</span>
    }
<span class="cstat-no" title="statement not covered" >    return sameValue(argument1.value, argument2.value);</span>
  });
}
&nbsp;
<span class="fstat-no" title="function not covered" >function sameValue(value1, value2) {</span>
<span class="cstat-no" title="statement not covered" >  return !value1 &amp;&amp; !value2 || (0, _printer.print)(value1) === (0, _printer.print)(value2);</span>
}
&nbsp;
// Two types conflict if both types could not apply to a value simultaneously.
// Composite types are ignored as their individual field types will be compared
// later recursively. However List and Non-Null types must match.
<span class="fstat-no" title="function not covered" >function doTypesConflict(type1, type2) {</span>
<span class="cstat-no" title="statement not covered" >  if (type1 instanceof _definition.GraphQLList) {</span>
<span class="cstat-no" title="statement not covered" >    return type2 instanceof _definition.GraphQLList ? doTypesConflict(type1.ofType, type2.ofType) : true;</span>
  }
<span class="cstat-no" title="statement not covered" >  if (type2 instanceof _definition.GraphQLList) {</span>
<span class="cstat-no" title="statement not covered" >    return type1 instanceof _definition.GraphQLList ? doTypesConflict(type1.ofType, type2.ofType) : true;</span>
  }
<span class="cstat-no" title="statement not covered" >  if (type1 instanceof _definition.GraphQLNonNull) {</span>
<span class="cstat-no" title="statement not covered" >    return type2 instanceof _definition.GraphQLNonNull ? doTypesConflict(type1.ofType, type2.ofType) : true;</span>
  }
<span class="cstat-no" title="statement not covered" >  if (type2 instanceof _definition.GraphQLNonNull) {</span>
<span class="cstat-no" title="statement not covered" >    return type1 instanceof _definition.GraphQLNonNull ? doTypesConflict(type1.ofType, type2.ofType) : true;</span>
  }
<span class="cstat-no" title="statement not covered" >  if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {</span>
<span class="cstat-no" title="statement not covered" >    return type1 !== type2;</span>
  }
<span class="cstat-no" title="statement not covered" >  return false;</span>
}
&nbsp;
// Given a selection set, return the collection of fields (a mapping of response
// name to field nodes and definitions) as well as a list of fragment names
// referenced via fragment spreads.
<span class="fstat-no" title="function not covered" >function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {</span>
<span class="cstat-no" title="statement not covered" >  var cached = cachedFieldsAndFragmentNames.get(selectionSet);</span>
<span class="cstat-no" title="statement not covered" >  if (!cached) {</span>
<span class="cstat-no" title="statement not covered" >    var nodeAndDefs = {};</span>
<span class="cstat-no" title="statement not covered" >    var fragmentNames = {};</span>
<span class="cstat-no" title="statement not covered" >    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);</span>
<span class="cstat-no" title="statement not covered" >    cached = [nodeAndDefs, Object.keys(fragmentNames)];</span>
<span class="cstat-no" title="statement not covered" >    cachedFieldsAndFragmentNames.set(selectionSet, cached);</span>
  }
<span class="cstat-no" title="statement not covered" >  return cached;</span>
}
&nbsp;
// Given a reference to a fragment, return the represented collection of fields
// as well as a list of nested fragment names referenced via fragment spreads.
<span class="fstat-no" title="function not covered" >function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {</span>
  // Short-circuit building a type from the node if possible.
<span class="cstat-no" title="statement not covered" >  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);</span>
<span class="cstat-no" title="statement not covered" >  if (cached) {</span>
<span class="cstat-no" title="statement not covered" >    return cached;</span>
  }
&nbsp;
<span class="cstat-no" title="statement not covered" >  var fragmentType = (0, _typeFromAST.typeFromAST)(context.getSchema(), fragment.typeCondition);</span>
<span class="cstat-no" title="statement not covered" >  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);</span>
}
&nbsp;
<span class="fstat-no" title="function not covered" >function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {</span>
<span class="cstat-no" title="statement not covered" >  for (var i = 0; i &lt; selectionSet.selections.length; i++) {</span>
<span class="cstat-no" title="statement not covered" >    var selection = selectionSet.selections[i];</span>
<span class="cstat-no" title="statement not covered" >    switch (selection.kind) {</span>
      case _kinds.FIELD:
<span class="cstat-no" title="statement not covered" >        var fieldName = selection.name.value;</span>
<span class="cstat-no" title="statement not covered" >        var fieldDef = void 0;</span>
<span class="cstat-no" title="statement not covered" >        if (parentType instanceof _definition.GraphQLObjectType || parentType instanceof _definition.GraphQLInterfaceType) {</span>
<span class="cstat-no" title="statement not covered" >          fieldDef = parentType.getFields()[fieldName];</span>
        }
<span class="cstat-no" title="statement not covered" >        var responseName = selection.alias ? selection.alias.value : fieldName;</span>
<span class="cstat-no" title="statement not covered" >        if (!nodeAndDefs[responseName]) {</span>
<span class="cstat-no" title="statement not covered" >          nodeAndDefs[responseName] = [];</span>
        }
<span class="cstat-no" title="statement not covered" >        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);</span>
<span class="cstat-no" title="statement not covered" >        break;</span>
      case _kinds.FRAGMENT_SPREAD:
<span class="cstat-no" title="statement not covered" >        fragmentNames[selection.name.value] = true;</span>
<span class="cstat-no" title="statement not covered" >        break;</span>
      case _kinds.INLINE_FRAGMENT:
<span class="cstat-no" title="statement not covered" >        var typeCondition = selection.typeCondition;</span>
<span class="cstat-no" title="statement not covered" >        var inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;</span>
<span class="cstat-no" title="statement not covered" >        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);</span>
<span class="cstat-no" title="statement not covered" >        break;</span>
    }
  }
}
&nbsp;
// Given a series of Conflicts which occurred between two sub-fields, generate
// a single Conflict.
<span class="fstat-no" title="function not covered" >function subfieldConflicts(conflicts, responseName, node1, node2) {</span>
<span class="cstat-no" title="statement not covered" >  if (conflicts.length &gt; 0) {</span>
<span class="cstat-no" title="statement not covered" >    return [[responseName, conflicts.map(<span class="fstat-no" title="function not covered" >function (_ref3) {</span></span>
<span class="cstat-no" title="statement not covered" >      var reason = _ref3[0];</span>
<span class="cstat-no" title="statement not covered" >      return reason;</span>
    })], conflicts.reduce(<span class="fstat-no" title="function not covered" >function (allFields, _ref4) {</span>
<span class="cstat-no" title="statement not covered" >      var fields1 = _ref4[1];</span>
<span class="cstat-no" title="statement not covered" >      return allFields.concat(fields1);</span>
    }, [node1]), conflicts.reduce(<span class="fstat-no" title="function not covered" >function (allFields, _ref5) {</span>
<span class="cstat-no" title="statement not covered" >      var fields2 = _ref5[2];</span>
<span class="cstat-no" title="statement not covered" >      return allFields.concat(fields2);</span>
    }, [node2])];
  }
}
&nbsp;
/**
 * A way to keep track of pairs of things when the ordering of the pair does
 * not matter. We do this by maintaining a sort of double adjacency sets.
 */
&nbsp;
var PairSet = function () {
<span class="fstat-no" title="function not covered" >  function PairSet() {</span>
<span class="cstat-no" title="statement not covered" >    _classCallCheck(this, PairSet);</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >    this._data = Object.create(null);</span>
  }
&nbsp;
  PairSet.prototype.has = <span class="fstat-no" title="function not covered" >function has(a, b, areMutuallyExclusive) {</span>
<span class="cstat-no" title="statement not covered" >    var first = this._data[a];</span>
<span class="cstat-no" title="statement not covered" >    var result = first &amp;&amp; first[b];</span>
<span class="cstat-no" title="statement not covered" >    if (result === undefined) {</span>
<span class="cstat-no" title="statement not covered" >      return false;</span>
    }
    // areMutuallyExclusive being false is a superset of being true,
    // hence if we want to know if this PairSet "has" these two with no
    // exclusivity, we have to ensure it was added as such.
<span class="cstat-no" title="statement not covered" >    if (areMutuallyExclusive === false) {</span>
<span class="cstat-no" title="statement not covered" >      return result === false;</span>
    }
<span class="cstat-no" title="statement not covered" >    return true;</span>
  };
&nbsp;
  PairSet.prototype.add = <span class="fstat-no" title="function not covered" >function add(a, b, areMutuallyExclusive) {</span>
<span class="cstat-no" title="statement not covered" >    _pairSetAdd(this._data, a, b, areMutuallyExclusive);</span>
<span class="cstat-no" title="statement not covered" >    _pairSetAdd(this._data, b, a, areMutuallyExclusive);</span>
  };
&nbsp;
  return PairSet;
}();
&nbsp;
<span class="fstat-no" title="function not covered" >function _pairSetAdd(data, a, b, areMutuallyExclusive) {</span>
<span class="cstat-no" title="statement not covered" >  var map = data[a];</span>
<span class="cstat-no" title="statement not covered" >  if (!map) {</span>
<span class="cstat-no" title="statement not covered" >    map = Object.create(null);</span>
<span class="cstat-no" title="statement not covered" >    data[a] = map;</span>
  }
<span class="cstat-no" title="statement not covered" >  map[b] = areMutuallyExclusive;</span>
}
&nbsp;</pre></td></tr>
</table></pre>
</div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Mon Apr 17 2017 11:47:51 GMT+0000 (UTC)</div>
</div>
</body>
</html>
